//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: clif/python/clif/proto_util.clif

#include <memory>
#include "absl/types/optional.h"
#include "clif/python/proto_util.h"
#include "clif/python/postconv.h"

namespace clif_proto {
using namespace ::clif;

// CLIF use `::clif_proto::MethodInfo` as MethodInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::MethodInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::MethodInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::MethodInfo>* output);
bool Clif_PyObjAs(PyObject* input, ::clif_proto::MethodInfo* output);
bool Clif_PyObjAs(PyObject* input, ::absl::optional<::clif_proto::MethodInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::MethodInfo*, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::MethodInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::MethodInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(::clif_proto::MethodInfo&&, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::MethodInfo&, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::MethodInfo*, const py::PostConv&);
// CLIF use `::clif_proto::ProtoFileInfo` as ProtoFileInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ProtoFileInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::ProtoFileInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::ProtoFileInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::ProtoFileInfo*, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::ProtoFileInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::ProtoFileInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoFileInfo*, const py::PostConv&) = delete;
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoFileInfo&, const py::PostConv&) = delete;
// CLIF use `::clif_proto::ProtoTypeInfo` as ProtoTypeInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ProtoTypeInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::ProtoTypeInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::ProtoTypeInfo>* output);
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ProtoTypeInfo* output);
bool Clif_PyObjAs(PyObject* input, ::absl::optional<::clif_proto::ProtoTypeInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::ProtoTypeInfo*, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::ProtoTypeInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::ProtoTypeInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(::clif_proto::ProtoTypeInfo&&, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoTypeInfo&, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoTypeInfo*, const py::PostConv&);
// CLIF use `::clif_proto::ServiceInfo` as ServiceInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ServiceInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::ServiceInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::ServiceInfo>* output);
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ServiceInfo* output);
bool Clif_PyObjAs(PyObject* input, ::absl::optional<::clif_proto::ServiceInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::ServiceInfo*, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::ServiceInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::ServiceInfo>, const py::PostConv&);
PyObject* Clif_PyObjFrom(::clif_proto::ServiceInfo&&, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::ServiceInfo&, const py::PostConv&);
PyObject* Clif_PyObjFrom(const ::clif_proto::ServiceInfo*, const py::PostConv&);

}  // namespace clif_proto

// CLIF init_module if (PyObject* m = PyImport_ImportModule("clif.python.utils.proto_util")) Py_DECREF(m);
// CLIF init_module else goto err;
